<!doctype html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.0" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Android,文件存储," />








  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.0" />






<meta name="description" content="SharePreferences（后续简称SP）相信大部分开发者都会用到，现在大部分的App可能也都仍在使用。千牛中也一直在使用SP文件来存储部分设置以及其他数据，也相安无事。不过最近版本去经常收到用户反馈设置了参数后，过段时间，设置就还原回去了… 百思不得其解，难道SP这么不稳定？于是趁着这两天得闲决定好好研究下。 本文主要针对在多进程环境下，同时针对源码做分析这中间存在的坑以及使用的注意点，有">
<meta name="keywords" content="Android,文件存储">
<meta property="og:type" content="article">
<meta property="og:title" content="聊聊SharePreferences的坑">
<meta property="og:url" content="http://yoursite.com/2017/04/09/聊聊SharePreferences的坑/index.html">
<meta property="og:site_name" content="笔歌的博客">
<meta property="og:description" content="SharePreferences（后续简称SP）相信大部分开发者都会用到，现在大部分的App可能也都仍在使用。千牛中也一直在使用SP文件来存储部分设置以及其他数据，也相安无事。不过最近版本去经常收到用户反馈设置了参数后，过段时间，设置就还原回去了… 百思不得其解，难道SP这么不稳定？于是趁着这两天得闲决定好好研究下。 本文主要针对在多进程环境下，同时针对源码做分析这中间存在的坑以及使用的注意点，有">
<meta property="og:updated_time" content="2017-04-09T07:55:33.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="聊聊SharePreferences的坑">
<meta name="twitter:description" content="SharePreferences（后续简称SP）相信大部分开发者都会用到，现在大部分的App可能也都仍在使用。千牛中也一直在使用SP文件来存储部分设置以及其他数据，也相安无事。不过最近版本去经常收到用户反馈设置了参数后，过段时间，设置就还原回去了… 百思不得其解，难道SP这么不稳定？于是趁着这两天得闲决定好好研究下。 本文主要针对在多进程环境下，同时针对源码做分析这中间存在的坑以及使用的注意点，有">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/04/09/聊聊SharePreferences的坑/"/>





  <title> 聊聊SharePreferences的坑 | 笔歌的博客 </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  














  
  
    
  

  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">笔歌的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/04/09/聊聊SharePreferences的坑/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="笔歌">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="笔歌的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                聊聊SharePreferences的坑
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-04-09T15:53:15+08:00">
                2017-04-09
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Android/" itemprop="url" rel="index">
                    <span itemprop="name">Android</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>SharePreferences（后续简称SP）相信大部分开发者都会用到，现在大部分的App可能也都仍在使用。千牛中也一直在使用SP文件来存储部分设置以及其他数据，也相安无事。不过最近版本去经常收到用户反馈设置了参数后，过段时间，设置就还原回去了… 百思不得其解，难道SP这么不稳定？于是趁着这两天得闲决定好好研究下。</p>
<p>本文主要针对在多进程环境下，同时针对源码做分析这中间存在的坑以及使用的注意点，有错误之处大家请指正~~</p>
<h2 id="1、-Case演示"><a href="#1、-Case演示" class="headerlink" title="1、 Case演示"></a>1、 Case演示</h2><h3 id="1-1-使用方式"><a href="#1-1-使用方式" class="headerlink" title="1.1 使用方式"></a>1.1 使用方式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">class KVStoreUtils &#123;</div><div class="line">	SharePreferences spInst;</div><div class="line">	</div><div class="line">	public KVStoreUtils(context)&#123;</div><div class="line">		spInst = context.getSharedPreferences(spName, Context.MODE_MULTI_PROCESS);</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public void put(k,v) &#123;</div><div class="line">		spInst.edit().putString(k,v).commit();</div><div class="line">	&#125;</div><div class="line">	</div><div class="line">	public String get(K) &#123;</div><div class="line">		return spInst.get(k);</div><div class="line">	&#125;</div><div class="line">	...</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中：</p>
<ol>
<li>应用自己保存了SharePreferences实例并使用（注意，这会影响很大哦，后续篇章会解释）。</li>
<li>为了支持跨进程，使用了_Context.MODE_MULTI<em>PROCESS</em> 模式。</li>
<li>为了便于讨论，全部使用commit方式。</li>
</ol>
<h3 id="1-2-测试场景"><a href="#1-2-测试场景" class="headerlink" title="1.2 测试场景"></a>1.2 测试场景</h3><ul>
<li>两个进程，后续分别命名为：main和other。</li>
<li>主进程启动后，会立马启动other进程，同时，进程启动后会读取sp文件的内容并打印。</li>
<li>进程使用同一个sp文件，即名称相同。</li>
<li>为了减少影响，所有修改操作全部使用commit方式。</li>
</ul>
<h3 id="1-3-测试用例以及结果"><a href="#1-3-测试用例以及结果" class="headerlink" title="1.3 测试用例以及结果"></a>1.3 测试用例以及结果</h3><p>来模拟下用户的场景，在已有的SP文件基础上更改数据，来看下有什么样的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">// 1.启动两个进程，可以看到初始化后二者sp文件内容相同</div><div class="line">main:: Create Multi Mode SP.</div><div class="line">main:: getAll...</div><div class="line">main:: getAll: k1_main, k1</div><div class="line">main:: getAll: same_k1, same_1main</div><div class="line">other:: Create Multi Mode SP.</div><div class="line">other:: getAll...</div><div class="line">other:: getAll: k1_main, k1</div><div class="line">other:: getAll: same_k1, same_1main</div><div class="line"></div><div class="line">// 2. main进程更改same_k1的value，打印sp后可以看到值生效</div><div class="line">main:: reset: same_k1 to modify_main</div><div class="line">main:: getAll...</div><div class="line">main:: getAll: k1_main, k1</div><div class="line">main:: getAll: same_k1, modify_main</div><div class="line"></div><div class="line">// 3. other进程添加一个新的值，打印后可以看到生效，但是same_k1对应的value却不是main修改后的</div><div class="line">other:: put: other, new_other</div><div class="line">other:: getAll...</div><div class="line">other:: getAll: other, new_other</div><div class="line">other:: getAll: k1_main, k1</div><div class="line">other:: getAll: same_k1, same_1main</div><div class="line"></div><div class="line">// 4. main进程再一次打印sp文件，也没有other进程添加的新值</div><div class="line">main:: getAll...</div><div class="line">main:: getAll: k1_main, k1</div><div class="line">main:: getAll: same_k1, modify_main</div><div class="line"></div><div class="line">// 5. 杀进程重启，却发现sp文件读出来后是other进程的值</div><div class="line">main:: Create Multi Mode SP.</div><div class="line">main:: getAll...</div><div class="line">main:: getAll: other, new_other</div><div class="line">main:: getAll: k1_main, k1</div><div class="line">main:: getAll: same_k1, same_1main</div><div class="line"></div><div class="line">other:: Create Multi Mode SP.</div><div class="line">other:: getAll...</div><div class="line">other:: getAll: other, new_other</div><div class="line">other:: getAll: k1_main, k1</div><div class="line">other:: getAll: same_k1, same_1main</div></pre></td></tr></table></figure>
<h3 id="1-4-结果"><a href="#1-4-结果" class="headerlink" title="1.4 结果"></a>1.4 结果</h3><p>综合两个case的结果，我们可以看到，实际上 _Context.MODE_MULTI<em>PROCESS</em> 没有生效，SP文件实际最终的值永远都是最后访问它的进程的备份的值。SharePreferences这种使用方式仅能保证进程不被杀时这个过程中的进程内一致性。</p>
<h2 id="2-Read-the-Fucking-Source-Code"><a href="#2-Read-the-Fucking-Source-Code" class="headerlink" title="2. Read the Fucking Source Code"></a>2. Read the Fucking Source Code</h2><p>记得一开始千牛做分进程时就考虑到数据共享问题，当时看到sp有一个_Context.MODE_MULTI<em>PROCESS</em>，虽然已经提示被废弃了，但也没有太深究，但现在看来这个还是不可靠的。</p>
<h3 id="2-1-DOC中官方解释"><a href="#2-1-DOC中官方解释" class="headerlink" title="2.1 DOC中官方解释"></a>2.1 DOC中官方解释</h3><p>SharePreferences中有这么一段值</p>
<blockquote>
<p>Note: This class does not support use across multiple processes.</p>
</blockquote>
<p>嗯，是的，官方文档现在已经明确说明不支持跨进程了，记得最初看的时候也没这么说过…</p>
<p>然后，针对 _Context.MODE_MULTI<em>PROCESS</em> 官方也有这么一段注释：</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt; This constant was deprecated in API level 23. MODE_MULTI_PROCESS does not work reliably in some versions of Android, and furthermore does not provide any mechanism for reconciling concurrent modifications across processes. Applications should not attempt to use it. Instead, they should use an explicit cross-process data management approach such as ContentProvider.</div><div class="line">&gt;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>嗯，改模式不保证reliably。看来Google曾经也尝试过简单方式的跨进程数据共享，但发现问题太多所以还是放弃，最后推荐跨进程共享数据还是要使用ContentProvider来代替（以后再花一篇文章来做吧）。</p>
<p>虽然官方文档的这点解释能够说明在千牛的多进程环境下，sp文件是不稳定的，但也还没完全解释通为什么用户的数据被还原。</p>
<h3 id="2-2-SharePreferences的获取"><a href="#2-2-SharePreferences的获取" class="headerlink" title="2.2 SharePreferences的获取"></a>2.2 SharePreferences的获取</h3><h4 id="2-2-1-Context-getSharePreferences"><a href="#2-2-1-Context-getSharePreferences" class="headerlink" title="2.2.1 Context.getSharePreferences()"></a>2.2.1 Context.getSharePreferences()</h4><p>发现4.0版本的Android代码较简洁，高版本只是做了优化，流程还是一样的，我们就贴下4.0版本的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public SharedPreferences getSharedPreferences(String name, int mode) &#123;</div><div class="line">    SharedPreferencesImpl sp;</div><div class="line">    synchronized (sSharedPrefs) &#123;</div><div class="line">        sp = sSharedPrefs.get(name);</div><div class="line">        if (sp == null) &#123;</div><div class="line">            File prefsFile = getSharedPrefsFile(name);</div><div class="line">            sp = new SharedPreferencesImpl(prefsFile, mode);</div><div class="line">            sSharedPrefs.put(name, sp);</div><div class="line">            return sp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    if ((mode &amp; Context.MODE_MULTI_PROCESS) != 0 ||</div><div class="line">        getApplicationInfo().targetSdkVersion &lt; android.os.Build.VERSION_CODES.HONEYCOMB) &#123;</div><div class="line">        // If somebody else (some other process) changed the prefs</div><div class="line">        // file behind our back, we reload it.  This has been the</div><div class="line">        // historical (if undocumented) behavior.</div><div class="line">        sp.startReloadIfChangedUnexpectedly();</div><div class="line">    &#125;</div><div class="line">    return sp;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>获取就分了两步:</p>
<ul>
<li>第一步，先查询静态map中是否之前已经打开过并有了备份，如果有了就直接从map中返回，没有就load from file.</li>
<li>第二步，注意看后面的对 _Context.MODE_MULTI<em>PROCESS</em> 的处理，在低于HONEYCOMB（api11）或设置了该mode就会判断文件是否已经变更了并重新加载（函数startReloadIfChangedUnexpectedly）。</li>
</ul>
<blockquote>
<p>一号坑位：如果app用户代码自己保存了SharePreference实例，就像上文case中的代码演示那样，而不是每次操作都从Context中获取，将不会判断变更reload，当然也就不会保证进程同步。所以，多进程环境下，建议为每个进程创建自己的名称的sp文件，不要公用一个，特别是你没有公用数据的情况。</p>
</blockquote>
<h3 id="2-3-SharePreference的实现"><a href="#2-3-SharePreference的实现" class="headerlink" title="2.3 SharePreference的实现"></a>2.3 SharePreference的实现</h3><p>用过sp存储的肯定对它都不陌生，基本都会知道其内部做了内存缓存，来保证能够在ui线程中使用，同时还有个apply和commit两种提交更改的方式，一个是异步一个是同步。但是现实真的就这么美好吗？</p>
<h4 id="2-3-1-构造SharePreferences实例"><a href="#2-3-1-构造SharePreferences实例" class="headerlink" title="2.3.1 构造SharePreferences实例"></a>2.3.1 构造SharePreferences实例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">SharedPreferencesImpl(File file, int mode) &#123;</div><div class="line">    mFile = file;</div><div class="line">    mBackupFile = makeBackupFile(file);</div><div class="line">    mMode = mode;</div><div class="line">    mLoaded = false;</div><div class="line">    mMap = null;</div><div class="line">    startLoadFromDisk();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里还是比较清晰的，配置文件以及mode，最后startLoadFromDisk初始化缓存mMap(该函数就不贴代码了，比较简单）。</p>
<blockquote>
<p>注意，load的操作是在异步Thread中执行的，貌似不会阻塞UI线程，应该还可以~~</p>
</blockquote>
<h4 id="2-3-2-startReloadIfChangedUnexpectedly"><a href="#2-3-2-startReloadIfChangedUnexpectedly" class="headerlink" title="2.3.2 startReloadIfChangedUnexpectedly"></a>2.3.2 startReloadIfChangedUnexpectedly</h4><p>跨进程同步方式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">void startReloadIfChangedUnexpectedly() &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">        // TODO: wait for any pending writes to disk?</div><div class="line">        if (!hasFileChangedUnexpectedly()) &#123;</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        startLoadFromDisk();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中，hasFileChangedUnexpectedly()判断方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return mStatTimestamp != stat.st_mtime || mStatSize != stat.st_size;</div></pre></td></tr></table></figure>
<p>总体来说逻辑还是比较清晰的，判断文件的modify时间戳以及文件大小是否有变更，如果有则认为已经过期，然后重新从disk中加载。</p>
<h4 id="2-3-3-get操作"><a href="#2-3-3-get操作" class="headerlink" title="2.3.3 get操作"></a>2.3.3 get操作</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">public String getString(String key, String defValue) &#123;</div><div class="line">    synchronized (this) &#123;</div><div class="line">        awaitLoadedLocked();</div><div class="line">        String v = (String)mMap.get(key);</div><div class="line">        return v != null ? v : defValue;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>逻辑更简单，等待初始化load锁完成后就直接从内存中读取。</p>
<blockquote>
<p>注：嗯看起来没问题啊，直接从内存的map中读取，在UI线程是使用完全没有问题！！你信么！！注意，方法awaitLoadedLocked().</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">private void awaitLoadedLocked() &#123;</div><div class="line">    if (!mLoaded) &#123;</div><div class="line">        // Raise an explicit StrictMode onReadFromDisk for this</div><div class="line">        // thread, since the real read will be in a different</div><div class="line">        // thread and otherwise ignored by StrictMode.</div><div class="line">        BlockGuard.getThreadPolicy().onReadFromDisk();</div><div class="line">    &#125;</div><div class="line">    while (!mLoaded) &#123;</div><div class="line">        try &#123;</div><div class="line">            wait();</div><div class="line">        &#125; catch (InterruptedException unused) &#123;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>二号坑位来了：可以看到，这个await是会等待mLoaded的，而这个是什么，是等待startLoadFromDisk()执行结束。那么问题来了，加入get操作都在ui线程，当初次使用时，这个可是要阻塞线程的，加载一个文件特别是一个大文件就有可能引起anr的问题。同样，如果使用了_Context.MODE_MULTI<em>PROCESS</em> 模式，那其他进程修改文件后都会面临load，那这个问题可就不是只有初次使用时才发生的了。</p>
</blockquote>
<h4 id="2-3-4-commit和apply操作"><a href="#2-3-4-commit和apply操作" class="headerlink" title="2.3.4 commit和apply操作"></a>2.3.4 commit和apply操作</h4><p>更改sp文件是会借助到起内部类EditorImpl，使用到Builder的设计模式来完成，改模式在android源代码中还是很常见的。该类代码较多，简单来说EditorImpl内存设置了map，用于先缓存用户的modify的k-v。然后最后等待用户调用apply或者commit之后完成写文件。<br>先看下Commit：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">public boolean commit() &#123;</div><div class="line">    MemoryCommitResult mcr = commitToMemory();</div><div class="line">    SharedPreferencesImpl.this.enqueueDiskWrite(</div><div class="line">        mcr, null /* sync write on this thread okay */);</div><div class="line">    try &#123;</div><div class="line">        mcr.writtenToDiskLatch.await();</div><div class="line">    &#125; catch (InterruptedException e) &#123;</div><div class="line">        return false;</div><div class="line">    &#125;</div><div class="line">    notifyListeners(mcr);</div><div class="line">    return mcr.writeToDiskResult;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>还是比较容易理解的，先提交到内存中，然后写文件，最后提交写完后才会通知listener。</p>
<blockquote>
<p>注意，写文件其实是提交到一个singleThreadExecutor完成的，主要目的是保证无论是使用commit还是apply，sp的内容永远是按照调用的顺序来执行，防止内容出现时序错乱。</p>
</blockquote>
<p>apply和commit类似，但核心区别在于少了一个latch锁的等待，因此是写完内存，并发起异步文件写任务后就溜了。代码就不再贴了。</p>
<blockquote>
<p>注意：为了效率，不要以为apply是异步的就可以多次apply了，其每次都会生成一个单独的任务提交，SharePreference还没智能到帮你合并apply的操作，所以尽可能把所有变更都添加到editor中后再commit或apply。后面会看到每次提交的任务处理是多重了。</p>
</blockquote>
<h4 id="2-3-5-函数commitToMemory（）"><a href="#2-3-5-函数commitToMemory（）" class="headerlink" title="2.3.5 函数commitToMemory（）"></a>2.3.5 函数commitToMemory（）</h4><p>改函数整体逻辑还是比较好理解的，直接把Editor中的modifyMap全部更新到SP对象实例内存中的mMap中。同时返回参数MemoryCommitResult，不过该Result类有一个成员变量值得注意：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">public Map&lt;?, ?&gt; mapToWriteToDisk;</div></pre></td></tr></table></figure>
<p>从命名可以看出是用于写入disp文件的map。在commitToMemory中有这么一行代码值得注意的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">mcr.mapToWriteToDisk = mMap;    // 注意：mMap是SharePreference的内存缓存</div></pre></td></tr></table></figure>
<p>从这行代码可以看出，每次commit或apply的时候，都会使用一份完整的内存中map数据重新写入的，所以，每次commit和apply都会生成一次很重的IO操作，想想假如map很大是的情景~~ 同时，这也解释了上文case中的现象，A进程先修改，但B进程随后任何的一个提交操作都会导致最终的SP文件中A修改的key被还原。</p>
<p>所以，假如在某些版本这种跨进程方式有问题，或者一旦出现时序的错乱，数据就会被还原了，用户反馈的设置被还原也就能解释通了。</p>
<h4 id="2-3-6-写文件"><a href="#2-3-6-写文件" class="headerlink" title="2.3.6 写文件"></a>2.3.6 写文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div></pre></td><td class="code"><pre><div class="line">// Note: must hold mWritingToDiskLock</div><div class="line">private void writeToFile(MemoryCommitResult mcr) &#123;</div><div class="line">    // Rename the current file so it may be used as a backup during the next read</div><div class="line">    if (mFile.exists()) &#123;</div><div class="line">        if (!mcr.changesMade) &#123;</div><div class="line">            // If the file already exists, but no changes were</div><div class="line">            // made to the underlying map, it&apos;s wasteful to</div><div class="line">            // re-write the file.  Return as if we wrote it</div><div class="line">            // out.</div><div class="line">            mcr.setDiskWriteResult(true);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        if (!mBackupFile.exists()) &#123;</div><div class="line">            if (!mFile.renameTo(mBackupFile)) &#123;</div><div class="line">                Log.e(TAG, &quot;Couldn&apos;t rename file &quot; + mFile</div><div class="line">                      + &quot; to backup file &quot; + mBackupFile);</div><div class="line">                mcr.setDiskWriteResult(false);</div><div class="line">                return;</div><div class="line">            &#125;</div><div class="line">        &#125; else &#123;</div><div class="line">            mFile.delete();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    // Attempt to write the file, delete the backup and return true as atomically as</div><div class="line">    // possible.  If any exception occurs, delete the new file; next time we will restore</div><div class="line">    // from the backup.</div><div class="line">    try &#123;</div><div class="line">        FileOutputStream str = createFileOutputStream(mFile);</div><div class="line">        if (str == null) &#123;</div><div class="line">            mcr.setDiskWriteResult(false);</div><div class="line">            return;</div><div class="line">        &#125;</div><div class="line">        XmlUtils.writeMapXml(mcr.mapToWriteToDisk, str);</div><div class="line">        FileUtils.sync(str);</div><div class="line">        str.close();</div><div class="line">        ContextImpl.setFilePermissionsFromMode(mFile.getPath(), mMode, 0);</div><div class="line">        try &#123;</div><div class="line">            final StructStat stat = Os.stat(mFile.getPath());</div><div class="line">            synchronized (this) &#123;</div><div class="line">                mStatTimestamp = stat.st_mtime;</div><div class="line">                mStatSize = stat.st_size;</div><div class="line">            &#125;</div><div class="line">        &#125; catch (ErrnoException e) &#123;</div><div class="line">            // Do nothing</div><div class="line">        &#125;</div><div class="line">        // Writing was successful, delete the backup file if there is one.</div><div class="line">        mBackupFile.delete();</div><div class="line">        mcr.setDiskWriteResult(true);</div><div class="line">        return;</div><div class="line">    &#125; catch (XmlPullParserException e) &#123;</div><div class="line">        Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e);</div><div class="line">    &#125; catch (IOException e) &#123;</div><div class="line">        Log.w(TAG, &quot;writeToFile: Got exception:&quot;, e);</div><div class="line">    &#125;</div><div class="line">    // Clean up an unsuccessfully written file</div><div class="line">    if (mFile.exists()) &#123;</div><div class="line">        if (!mFile.delete()) &#123;</div><div class="line">            Log.e(TAG, &quot;Couldn&apos;t clean up partially-written file &quot; + mFile);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    mcr.setDiskWriteResult(false);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码比较长，简单说下流程，就是判断sp文件存在，就先重命名成backup文件（毕竟每次都是全量写入，所以老文件纯粹为了备份，没有合并的需求），在这个过程中如果发现backup文件已经存在，说明上次的提交异常中断了，就直接清除现在的sp文件；然后在将map内容全量写入到新创建的file中，成功后清理掉backup文件。</p>
<p>说实话，看到这个代码就感觉多进程不靠谱，进程没有同步锁，完全有可能多进程同时写入时就会出现后入为主了，数据丢失也是正常的。</p>
<h3 id="2-4-End"><a href="#2-4-End" class="headerlink" title="2.4 End"></a>2.4 End</h3><p>至此，代码核心的部分基本分析完了，如果还有感兴趣的部分大家可以自己再翻阅下代码，本文就不再赘述了。总结归纳：</p>
<ul>
<li>SharePreferences跨进程虽然有机制，但不靠谱，建议还是切换成ContentProvider。</li>
<li>_Context.MODE_MULTI<em>PROCESS</em> 还是如官方建议，不要再使用了。</li>
<li>使用SharePreferences尽量不要一个文件存储太多内容，特别是大数据，多了就要考虑拆分。</li>
<li>SharePreference如果如果存在多进程环境，尽量不同进程单独使用自己的文件，不可避免的话千万不要定义封装类来保存sp实例对象使用。</li>
<li>SharePreferences的get也有可能出现anr现象哦~</li>
<li>能合并提交的尽量合并，减少IO操作。</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Android/" rel="tag"># Android</a>
          
            <a href="/tags/文件存储/" rel="tag"># 文件存储</a>
          
        </div>
      

      
        
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/04/09/如何优化你的安卓应用：电量篇（一）了解电量消耗/" rel="next" title="如何优化你的安卓应用：电量篇（一）了解电量消耗">
                <i class="fa fa-chevron-left"></i> 如何优化你的安卓应用：电量篇（一）了解电量消耗
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/04/09/Github-hexo搭建Pages/" rel="prev" title="Github+hexo搭建Pages">
                Github+hexo搭建Pages <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="笔歌" />
          <p class="site-author-name" itemprop="name">笔歌</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">1</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">4</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1、-Case演示"><span class="nav-number">1.</span> <span class="nav-text">1、 Case演示</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-使用方式"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 使用方式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-测试场景"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 测试场景</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-测试用例以及结果"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 测试用例以及结果</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-结果"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 结果</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-Read-the-Fucking-Source-Code"><span class="nav-number">2.</span> <span class="nav-text">2. Read the Fucking Source Code</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-DOC中官方解释"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 DOC中官方解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-SharePreferences的获取"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 SharePreferences的获取</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-1-Context-getSharePreferences"><span class="nav-number">2.2.1.</span> <span class="nav-text">2.2.1 Context.getSharePreferences()</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-SharePreference的实现"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 SharePreference的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-1-构造SharePreferences实例"><span class="nav-number">2.3.1.</span> <span class="nav-text">2.3.1 构造SharePreferences实例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-2-startReloadIfChangedUnexpectedly"><span class="nav-number">2.3.2.</span> <span class="nav-text">2.3.2 startReloadIfChangedUnexpectedly</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-3-get操作"><span class="nav-number">2.3.3.</span> <span class="nav-text">2.3.3 get操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4-commit和apply操作"><span class="nav-number">2.3.4.</span> <span class="nav-text">2.3.4 commit和apply操作</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-5-函数commitToMemory（）"><span class="nav-number">2.3.5.</span> <span class="nav-text">2.3.5 函数commitToMemory（）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-6-写文件"><span class="nav-number">2.3.6.</span> <span class="nav-text">2.3.6 写文件</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-End"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 End</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">笔歌</span>
</div>



        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  






  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.0"></script>



  


  




	





  





  





  






  





  

  

  

  

</body>
</html>
